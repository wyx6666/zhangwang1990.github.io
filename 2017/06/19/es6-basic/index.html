<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> es6Basic · Wang's Plot</title><meta name="description" content="es6Basic - zhang wang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Wang's Plot"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/zhangwang1990" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">es6Basic</h1><div class="post-info">Jun 19, 2017</div><div class="post-content"><blockquote>
<p>ES6在2015年6月就得以批准，至今已两年了。近一年多以来陆续看过很多ES6的资料，工作项目中也逐步的用上了很多ES6的特性（<code>let</code>,<code>const</code>,<code>promise</code>,<code>Template strings</code>,<code>Class</code>,箭头函数等等），不得不说，这些特性给开发带来了非常的的便利。但是我的ES6知识其实并不够系统，这也是本文的成因，希望阅读本文能让你也能对ES6有更系统的理解，本文并不是那种大而全的教程，而是希望在实际工作中，能想起某个新特性可以解决你当前的问题或者优化当前的代码，然后再系统学习，应用，毕竟自己用过了才算掌握了。</p>
<p>本文基于Github上的高赞文章<a href="https://github.com/lukehoban/es6features" target="_blank" rel="external">ECMAScript 6 Features</a>/Babel修改过的<a href="https://babeljs.io/learn-es2015/" target="_blank" rel="external">Learn ES2015</a>,翻译（写作？）期间，重温了阮一峰老师的<a href="es6.ruanyifeng.com/#README">ECMAScript 6 入门</a>。</p>
</blockquote>
<a id="more"></a>
<h3 id="ES6新特性列表"><a href="#ES6新特性列表" class="headerlink" title="ES6新特性列表"></a>ES6新特性列表</h3><p>相比ES5，ES6提供了太多的更新，简单说来，主要为以下方面（大家可以依据自己不算清晰的点选择性查看本文）：</p>
<ul>
<li>Arrows,箭头函数，</li>
<li>Classes，类</li>
<li>Enhanced object literals，增强的对象字面值</li>
<li>Template strings：模板字符串</li>
<li>Destructuring：解构</li>
<li>Default + rest + spread：参数默认值，rest参数,扩展运算符</li>
<li>Let + const:命名声明的新方式</li>
<li>Iterators + for..of：遍历器</li>
<li>Generators：生成器</li>
<li>Unicode：更广泛的编码支持</li>
<li>Modules：语言层面上支持的模块机制</li>
<li>Module loaders：模块加载器</li>
<li>Map + set + weakmap + weakset：新的数据结构</li>
<li>Proxies：代理器</li>
<li>Symbols：新的基本类型，独一无二的值</li>
<li>Subclassable built-ins：类的继承</li>
<li>Promises：</li>
<li>Math + number + string + array + object apis：拓展了一些内置对象的方法</li>
<li>Binary and octal literals：二进制八进制字面量</li>
<li>Reflect api：操作对象的新api</li>
<li>Tail calls:尾调用</li>
</ul>
<h3 id="Arrows箭头函数"><a href="#Arrows箭头函数" class="headerlink" title="Arrows箭头函数"></a>Arrows箭头函数</h3><p>箭头函数使用类似于<code>=&gt;</code>这样的语法定义函数，支持表达式模式和语句模式，不过其最大特点在于和父作用域具有一样的<code>this</code>。我们知道普通函数的<code>this</code>在函数定义的时候就确定了，使用箭头函数时再也不用担心<code>this</code>跳来跳去了。<br>此外如果箭头函数如果定义在另一个函数里面，箭头函数会共享它父函数的arguments变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 表达式模式箭头函数</span></div><div class="line"><span class="keyword">var</span> odds = evens.map(<span class="function"><span class="params">v</span> =&gt;</span> v + <span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> nums = evens.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> v + i);</div><div class="line"><span class="keyword">var</span> pairs = evens.map(<span class="function"><span class="params">v</span> =&gt;</span> (&#123;<span class="attr">even</span>: v, <span class="attr">odd</span>: v + <span class="number">1</span>&#125;));</div><div class="line"></div><div class="line"><span class="comment">// 语句模式箭头函数</span></div><div class="line">nums.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">if</span> (v % <span class="number">5</span> === <span class="number">0</span>)</div><div class="line">    fives.push(v);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 和父作用域具有相同的this</span></div><div class="line"><span class="keyword">var</span> bob = &#123;</div><div class="line">  <span class="attr">_name</span>: <span class="string">"Bob"</span>,</div><div class="line">  <span class="attr">_friends</span>: [],</div><div class="line">  printFriends() &#123;</div><div class="line">    <span class="keyword">this</span>._friends.forEach(<span class="function"><span class="params">f</span> =&gt;</span></div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>._name + <span class="string">" knows "</span> + f));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> numbers = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> number <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</div><div class="line">      numbers.push(number * number);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> numbers;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> example();</div><div class="line">&#125;</div><div class="line"></div><div class="line">square(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">11.5</span>, <span class="number">21</span>); <span class="comment">// returns: [4, 16, 56.25, 64, 132.25, 441]</span></div></pre></td></tr></table></figure>
<h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>JavaScript中其实并不存在真正的类，ES6的类其实是基于原型链模拟面向对象的一种语法糖。其本质上可以看做是构造函数的另一种写法。<br>与真的类一样，它支持<code>super</code>继承，实例，静态方法和<code>constructor</code>方法。<br>如果你也使用React，工作中定义模块时一定没少写过<code>class A extends React.Component{}</code>吧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 通过extends关键字实现继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkinnedMesh</span> <span class="keyword">extends</span> <span class="title">THREE</span>.<span class="title">Mesh</span> </span>&#123;</div><div class="line">  <span class="comment">//constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。</span></div><div class="line">  <span class="comment">//一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</span></div><div class="line">  <span class="keyword">constructor</span>(geometry, materials) &#123;</div><div class="line">    <span class="comment">// super表示父类的构造函数，用来新建父类的this对象,</span></div><div class="line">    <span class="comment">// 子类必须在constructor方法中调用super方法，否则新建实例时会报错。如果不调用super方法，子类就得不到this对象。</span></div><div class="line">    <span class="keyword">super</span>(geometry, materials);</div><div class="line"></div><div class="line">    <span class="comment">//在构造方法中绑定this,可以防止实例找不到this</span></div><div class="line">    <span class="keyword">this</span>.idMatrix = SkinnedMesh.defaultMatrix();</div><div class="line">    <span class="keyword">this</span>.bones = [];</div><div class="line">    <span class="keyword">this</span>.boneMatrices = [];</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 非定义在this上的方法都会被直接定义在原型链上</span></div><div class="line">  update(camera) &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="comment">// super在此处作为对象，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</span></div><div class="line">    <span class="keyword">super</span>.update();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 可以使用get和set关键字，对某个属性设置存值函数和取值函数</span></div><div class="line">  get boneCount() &#123;</div><div class="line">  <span class="comment">// 类的方法内部如果含有this，它默认指向类的实例</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.bones.length;</div><div class="line">  &#125;</div><div class="line">  set matrixType(matrixType) &#123;</div><div class="line">    <span class="keyword">this</span>.idMatrix = SkinnedMesh[matrixType]();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用</span></div><div class="line">  <span class="keyword">static</span> defaultMatrix() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> THREE.Matrix4();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 类的所有实例共享一个原型对象</span></div><div class="line"><span class="keyword">let</span> skin = <span class="keyword">new</span> SkinnedMesh();</div><div class="line"><span class="comment">// 调用静态方法</span></div><div class="line">skin.defaultMatrix()</div></pre></td></tr></table></figure>
<h3 id="对象的拓展"><a href="#对象的拓展" class="headerlink" title="对象的拓展"></a>对象的拓展</h3><p>ES6中对象的使用方法得以拓展，主要包括以下几点：</p>
<ul>
<li>属性和方法可以简洁表示；</li>
<li>允许以表达式的模式定义属性名；</li>
<li>可以通过<code>__proto__</code>读取或设置当前对象的prototype对象;</li>
<li>使用<code>Object.is({},{})</code>判断两个对象是否完全相对，类似于<code>===</code>;</li>
<li><code>Object.assign(target, source1, source2)</code>合并对象；（浅拷贝）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="comment">// __proto__用以设置当前对象的prototype对象，不推荐使用，推荐使用Object.setPrototypeOf() </span></div><div class="line">    __proto__: theProtoObj,</div><div class="line">    <span class="comment">//‘handler:handler’可简写为handler（只需要写变量名就可以实现变量名为变量名，变量值为属性值）</span></div><div class="line">    handler,</div><div class="line">    <span class="comment">// 简写在定义方法的时候同样有效</span></div><div class="line">    toString() &#123;</div><div class="line">     <span class="comment">// Super calls</span></div><div class="line">     <span class="keyword">return</span> <span class="string">"d "</span> + <span class="keyword">super</span>.toString();</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 方括号内的表达式用以计算属性名</span></div><div class="line">    [ <span class="string">'prop_'</span> + <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="number">42</span>)() ]: <span class="number">42</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串是一种组合字符串的语法糖，其使用类似于<code>Perl</code>,<code>Python</code>等语言的字符串修改方法类似，它的出现让我们拼合字符串时方便多了。目前相互中几乎所有字符串的拼接都用这个了，异常方便。</p>
<ul>
<li>模板字符串定义在两个反撇号中；</li>
<li>在模板字符串中可以直接换行，格式会得以保留；</li>
<li>通过<code>${}</code>可以很方便的在模板字符串中添加变量；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把字符串放在``(注意不是引号)中就可以使用</span></div><div class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></div><div class="line"></div><div class="line"><span class="comment">// 模板字符串保留了换行</span></div><div class="line"><span class="string">`In JavaScript this is</span></div><div class="line"> not legal.`</div><div class="line"></div><div class="line"><span class="comment">// 在字符串中添加变量的方法，变量直接放在$&#123;&#125;中即可</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</div><div class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></div><div class="line"></div><div class="line"><span class="comment">// 拼合请求时异常方便了</span></div><div class="line">POST<span class="string">`http://foo.org/bar?a=<span class="subst">$&#123;a&#125;</span>&amp;b=<span class="subst">$&#123;b&#125;</span></span></div><div class="line">     Content-Type: application/json</div><div class="line">     X-Credentials: <span class="subst">$&#123;credentials&#125;</span></div><div class="line">     &#123; "foo": <span class="subst">$&#123;foo&#125;</span>,</div><div class="line">       "bar": <span class="subst">$&#123;bar&#125;</span>&#125;`(myOnReadyStateChangeHandler);</div></pre></td></tr></table></figure>
<h3 id="Destructuring-解构"><a href="#Destructuring-解构" class="headerlink" title="Destructuring 解构"></a>Destructuring 解构</h3><p>解构使用模式匹配的方法绑定变量和值，数组和对象都可使用。解构在绑定失败的时会实现软绑定，即没有匹配值时，返回<code>undefined</code>。使用方法可见示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组解构</span></div><div class="line"><span class="keyword">var</span> [a, , b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="comment">// a = 1,b = 3</span></div><div class="line"></div><div class="line"><span class="comment">// React中常见以下用法</span></div><div class="line"><span class="keyword">var</span> &#123;a, b, c&#125; = <span class="keyword">this</span>.props;</div><div class="line"></div><div class="line"><span class="comment">// 对象解构也能用在函数的参数中</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">&#123;name: x&#125;</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line">g(&#123;<span class="attr">name</span>: <span class="number">5</span>&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 绑定失败时返回undefined</span></div><div class="line"><span class="keyword">var</span> [a] = [];</div><div class="line">a === <span class="literal">undefined</span>;</div><div class="line"></div><div class="line"><span class="comment">// 解构时也可以绑定默认值</span></div><div class="line"><span class="keyword">var</span> [a = <span class="number">1</span>] = [];</div><div class="line">a === <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// 配合默认参数使用结构</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params">&#123;x, y, w = <span class="number">10</span>, h = <span class="number">10</span>&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y + w + h;</div><div class="line">&#125;</div><div class="line">r(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;) === <span class="number">23</span></div></pre></td></tr></table></figure>
<h3 id="默认值，剩余值和拓展值"><a href="#默认值，剩余值和拓展值" class="headerlink" title="默认值，剩余值和拓展值"></a>默认值，剩余值和拓展值</h3><ul>
<li>ES6允许我们在给变量添加默认值</li>
<li>使用拓展值使得函数调用时可传入数组作为连续的参数</li>
<li>利用剩余值特性我们可以把函数尾部的参数转换为一个数组，现在使用<code>rest</code>就可以替换以前的<code>arguments</code>对象了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 给函数的参数添加默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y=<span class="number">12</span></span>) </span>&#123;</div><div class="line">  <span class="comment">// y is 12 if not passed (or passed as undefined)</span></div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 可以只传参数x的值了</span></div><div class="line">f(<span class="number">3</span>) == <span class="number">15</span></div><div class="line"></div><div class="line"><span class="comment">// 使用rest</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, ...y</span>) </span>&#123;</div><div class="line">  <span class="comment">// y is an Array</span></div><div class="line">  <span class="keyword">return</span> x * y.length;</div><div class="line">&#125;</div><div class="line">f(<span class="number">3</span>, <span class="string">"hello"</span>, <span class="literal">true</span>) == <span class="number">6</span></div><div class="line"></div><div class="line"><span class="comment">// 传入数组作为参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y + z;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 直接传入数组当作上面函数的参数</span></div><div class="line">f(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) == <span class="number">6</span></div></pre></td></tr></table></figure>
<h3 id="Let-和-Const"><a href="#Let-和-Const" class="headerlink" title="Let 和 Const"></a>Let 和 Const</h3><p>ES6新增了块作用域，新增了两种定义变量的方法，定义变量时推荐使用<code>let</code>替代<code>var</code>，<code>let</code>定义的变量在块作用域内有效，<code>const</code>用以指定固定值，这两类新定义的变量不允许在定义前使用，也不允许重复定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">let</span> x;</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">const</span> x = <span class="string">"sneaky"</span>;</div><div class="line">      <span class="comment">// 改变const</span></div><div class="line">      x = <span class="string">"foo"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 重复定义会出错</span></div><div class="line">    <span class="keyword">let</span> x = <span class="string">"inner"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在这里想到一个使用var时新手特别容易犯的问题</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, i*<span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用var 所有的结果都是10</span></div><div class="line"><span class="comment">// 使用let 结果就是预想要的结果</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, i*<span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Iterators-For-Of"><a href="#Iterators-For-Of" class="headerlink" title="Iterators + For..Of"></a>Iterators + For..Of</h3><p>ES6为部署了Iterator接口的各种不同的数据结构提供了统一的访问机制。其本质是一个指针对象。每次调用<code>next</code>方法，可以把指针指向数据结构的下一个成员。具体说来，每一次调用next方法，都会返回数据结构的当前成员的信息（一个包含value和done两个属性的对象，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束）。</p>
<p>凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fibonacci = &#123;</div><div class="line">  <span class="comment">// 一个数据结构只要具有Symbol.iterator属性，就可被认为是可遍历的，`Symbol.iterator`是一个表达式，返回Symbol对象的iterator属性，所以需要放在[]中，本质上它是当前数据结构的遍历器生成函数。</span></div><div class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      next() &#123;</div><div class="line">        [pre, cur] = [cur, pre + cur];</div><div class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: cur &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// fibonacci部署了Symbol.iterator属性，只要done不为true就会一直遍历</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</div><div class="line"><span class="comment">// 调用1000以内的值做遍历</span></div><div class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="built_in">console</span>.log(n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>原生具备<code>Iterator</code>接口的数据结构有以下几种:数组、某些类似数组的对象（字符串、DOM NodeList 对象、arguments对象）、Set和Map结构。<br>对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>
<p>实际使用时需引入<a href="http://babeljs.io/docs/usage/polyfill/" target="_blank" rel="external">polyfill</a></p>
</blockquote>
<h3 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h3><p>可以从两个角度理解<code>Generators</code>，它既是状态机也是一个遍历器对象生成函数。执行该函数可以理解为启动了遍历器，之后每次执行<code>next()</code>函数则每次执行到<code>yield</code>处。</p>
<p>值得注意的是执行<code>next()</code>时可添加参数，这实现了在函数运行的不同阶段，可以从外部向内部注入不同的值，</p>
<p>生成器使用<code>function*</code>和<code>yield</code>简化了迭代过程，使用<code>function*</code>定义的函数返回了一个生成器实例。<br>生成器是迭代器的子类，但是包含<code>next</code>和<code>throw</code>。这使得值可以回流到生成器，<code>yield</code>是一个可以返回值的表达式。</p>
<p><code>for...of</code>循环可以自动遍历 <code>Generator</code> 函数时生成的<code>Iterator</code>对象，此时不再需要调用<code>next</code>方法。</p>
<p><code>Generator</code>的<code>return</code>方法会返回固定的值，终结遍历Generator函数。返回值的value属性就是return方法的参数，返回值的done属性为true。</p>
<p>结合<code>co</code>模块可以实现比Promise更加优雅的异步调用方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用generator函数实现上述遍历器对象</span></div><div class="line"><span class="keyword">var</span> fibonacci = &#123;</div><div class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">      <span class="keyword">var</span> temp = pre;</div><div class="line">      pre = cur;</div><div class="line">      cur += temp;</div><div class="line">      <span class="keyword">yield</span> cur;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</div><div class="line">  <span class="comment">// truncate the sequence at 1000</span></div><div class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="built_in">console</span>.log(n);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用co模块（基于 Promise 对象的自动执行器），可以实现异步函数的自动执行</span></div><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> somethingAsync();</div><div class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> anotherThingAsync();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</div><div class="line">co(gen);</div></pre></td></tr></table></figure>
<blockquote>
<p>实际使用时需引入<a href="http://babeljs.io/docs/usage/polyfill/" target="_blank" rel="external">polyfill</a></p>
</blockquote>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>ES6完整支持所有的Unicode,包括新的<code>Unicode</code>字面量和<code>u</code>模式正则，提供了新的API来处理<code>21bit</code>级别的字符串。这些新加特性使得我们的JavaScript应用有能力支持各种语言。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// same as ES5.1</span></div><div class="line"><span class="string">"𠮷"</span>.length == <span class="number">2</span></div><div class="line"></div><div class="line"><span class="comment">// 新的正则匹配模式</span></div><div class="line"><span class="string">"𠮷"</span>.match(<span class="regexp">/./u</span>)[<span class="number">0</span>].length == <span class="number">2</span></div><div class="line"></div><div class="line"><span class="comment">// 新形式</span></div><div class="line"><span class="string">"\u&#123;20BB7&#125;"</span>==<span class="string">"𠮷"</span>==<span class="string">"\uD842\uDFB7"</span></div><div class="line"></div><div class="line"><span class="comment">// codePointAt()能够正确处理4个字节储存的字符，返回一个字符的码点</span></div><div class="line"><span class="string">"𠮷"</span>.codePointAt(<span class="number">0</span>) == <span class="number">0x20BB7</span></div><div class="line"></div><div class="line"><span class="comment">// for-of 遍历字符，以整体输出</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> c <span class="keyword">of</span> <span class="string">"𠮷"</span>) &#123;</div><div class="line">  <span class="built_in">console</span>.log(c);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 𠮷</span></div></pre></td></tr></table></figure>
<h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>现代JS应用的开发离不开模块了，ES6对模块的定义提供了语言层面的支持。规范化了各种JavaScript模块加载器，支持运行时动态加载模块，支持异步加载模块。</p>
<p>ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，效率要比 CommonJS 模块的加载方式高。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lib/math.js 模块的定义</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> pi = <span class="number">3.141593</span>;</div><div class="line"></div><div class="line"><span class="comment">// app.js 模块的全部引用</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">"lib/math"</span>;</div><div class="line">alert(<span class="string">"2π = "</span> + math.sum(math.pi, math.pi));</div><div class="line"></div><div class="line"><span class="comment">// otherApp.js 模块的部分引用</span></div><div class="line"><span class="keyword">import</span> &#123;sum, pi&#125; <span class="keyword">from</span> <span class="string">"lib/math"</span>;</div><div class="line">alert(<span class="string">"2π = "</span> + sum(pi, pi));</div><div class="line"></div><div class="line"><span class="comment">// 模块导出方法</span></div><div class="line"><span class="comment">// lib/mathplusplus.js</span></div><div class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"lib/math"</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 混合引入方法</span></div><div class="line"><span class="keyword">import</span> ln, &#123;pi, e&#125; <span class="keyword">from</span> <span class="string">"lib/mathplusplus"</span>;</div><div class="line">alert(<span class="string">"2π = "</span> + ln(e)*pi*<span class="number">2</span>);</div></pre></td></tr></table></figure>
<h3 id="Module-Loaders（其实并非ES6标准的一部分，只是草案）"><a href="#Module-Loaders（其实并非ES6标准的一部分，只是草案）" class="headerlink" title="Module Loaders（其实并非ES6标准的一部分，只是草案）"></a>Module Loaders（其实并非ES6标准的一部分，只是草案）</h3><p>模块加载器支持以下功能：</p>
<ul>
<li>动态加载</li>
<li>状态隔离</li>
<li>全局命名空间隔离</li>
<li>编写钩子</li>
<li>嵌套</li>
</ul>
<p>默认的模块加载器可以被配置，新的加载器可以被配置来评估加载独立上下文中的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 动态加载 – ‘System’ 是默认的加载器</span></div><div class="line">System.import(<span class="string">'lib/math'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</div><div class="line">  alert(<span class="string">"2π = "</span> + m.sum(m.pi, m.pi));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 新的加载器创建了执行沙盒</span></div><div class="line"><span class="keyword">var</span> loader = <span class="keyword">new</span> Loader(&#123;</div><div class="line">  <span class="attr">global</span>: fixup(<span class="built_in">window</span>) <span class="comment">// replace ‘console.log’</span></div><div class="line">&#125;);</div><div class="line">loader.eval(<span class="string">"console.log('hello world!');"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 可以直接修改模块的缓存</span></div><div class="line">System.get(<span class="string">'jquery'</span>);</div><div class="line">System.set(<span class="string">'jquery'</span>, Module(&#123;<span class="attr">$</span>: $&#125;)); <span class="comment">// WARNING: not yet finalized</span></div></pre></td></tr></table></figure>
<h3 id="Map-Set-WeakMap-WeakSet"><a href="#Map-Set-WeakMap-WeakSet" class="headerlink" title="Map Set WeakMap WeakSet"></a>Map Set WeakMap WeakSet</h3><p>ES6为算法提供了新的高效的数据结构，<code>WeakMaps</code>提供了防泄漏的键值对表。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Set类似于数组，但是成员的值都是唯一的，没有重复的值。</span></div><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">s.add(<span class="string">"hello"</span>).add(<span class="string">"goodbye"</span>).add(<span class="string">"hello"</span>);</div><div class="line">s.size === <span class="number">2</span>;</div><div class="line">s.has(<span class="string">"hello"</span>) === <span class="literal">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// Map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</span></div><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">m.set(<span class="string">"hello"</span>, <span class="number">42</span>);</div><div class="line">m.set(s, <span class="number">34</span>);</div><div class="line">m.get(s) == <span class="number">34</span>;</div><div class="line"></div><div class="line"><span class="comment">// WeakMap结构与Map结构类似，也是用于生成键值对的集合，但是WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名，此外WeakMap的键名所指向的对象，不计入垃圾回收机制。</span></div><div class="line"><span class="keyword">var</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line">wm.set(s, &#123; <span class="attr">extra</span>: <span class="number">42</span> &#125;);</div><div class="line">wm.size === <span class="literal">undefined</span></div><div class="line"></div><div class="line"><span class="comment">// WeakSet 结构与 Set 类似，也是不重复的值的集合,但是WeakSet 的成员只能是对象，而不能是其他类型的值，此外WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用</span></div><div class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</div><div class="line">ws.add(&#123; <span class="attr">data</span>: <span class="number">42</span> &#125;);</div><div class="line"><span class="comment">// Because the added object has no other references, it will not be held in the set</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>实际使用时需引入<a href="http://babeljs.io/docs/usage/polyfill/" target="_blank" rel="external">polyfill</a></p>
</blockquote>
<h3 id="Proxies"><a href="#Proxies" class="headerlink" title="Proxies"></a>Proxies</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<blockquote>
<p>需要注意的是目前未被Babel支持，使用时需谨慎</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// target参数表示所要拦截的目标对象;</span></div><div class="line"><span class="keyword">var</span> target = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// handler参数也是一个对象，用来定制拦截行为;</span></div><div class="line"><span class="keyword">var</span> handler = &#123;</div><div class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">receiver, name</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 生成一个Proxy实例</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</div><div class="line">p.world === <span class="string">'Hello, world!'</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 对函数同样可以使用代理</span></div><div class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'I am the target'</span>; &#125;;</div><div class="line"><span class="keyword">var</span> handler = &#123;</div><div class="line">  <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span> (<span class="params">receiver, ...args</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'I am the proxy'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</div><div class="line">p() === <span class="string">'I am the proxy'</span>;</div></pre></td></tr></table></figure>
<p>// Proxy支持的拦截操作如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> handler =</div><div class="line">&#123;</div><div class="line">  <span class="attr">get</span>:...,</div><div class="line">  <span class="attr">set</span>:...,</div><div class="line">  <span class="attr">has</span>:...,</div><div class="line">  <span class="attr">deleteProperty</span>:...,</div><div class="line">  <span class="attr">apply</span>:...,</div><div class="line">  <span class="attr">construct</span>:...,</div><div class="line">  <span class="attr">getOwnPropertyDescriptor</span>:...,</div><div class="line">  <span class="attr">defineProperty</span>:...,</div><div class="line">  <span class="attr">getPrototypeOf</span>:...,</div><div class="line">  <span class="attr">setPrototypeOf</span>:...,</div><div class="line">  <span class="attr">enumerate</span>:...,</div><div class="line">  <span class="attr">ownKeys</span>:...,</div><div class="line">  <span class="attr">preventExtensions</span>:...,</div><div class="line">  <span class="attr">isExtensible</span>:...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Babel 不支持，使用时应注意</p>
</blockquote>
<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p><code>Symbol</code>保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名的冲突；<br>它是一种类似于字符串的数据类型,Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述；<br>Symbols是唯一的，单并非私有的，通过<code>Object.getOwnPropertySymbols</code>可以获取对应的值；<br>Symbol 值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyClass = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// module scoped symbol</span></div><div class="line">  <span class="keyword">var</span> key = <span class="built_in">Symbol</span>(<span class="string">"key"</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params">privateData</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>[key] = privateData;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  MyClass.prototype = &#123;</div><div class="line">    <span class="attr">doStuff</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      ... this[key] ...</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> MyClass;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> MyClass(<span class="string">"hello"</span>)</div><div class="line">c[<span class="string">"key"</span>] === <span class="literal">undefined</span></div></pre></td></tr></table></figure>
<blockquote>
<p>由于语言限制，Babel只提供部分支持，使用时需要注意</p>
</blockquote>
<h3 id="内置类的继承"><a href="#内置类的继承" class="headerlink" title="内置类的继承"></a>内置类的继承</h3><p>在ES6中，内置的<code>Array</code>,<code>Date</code>,<code>DOM Element</code>可以被继承以拓展了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// User code of Array subclass</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(...args) &#123; <span class="keyword">super</span>(...args); &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> MyArray();</div><div class="line">arr[<span class="number">1</span>] = <span class="number">12</span>;</div><div class="line">arr.length == <span class="number">2</span></div></pre></td></tr></table></figure>
<blockquote>
<p>babel 部分支持，由于ES5引擎的限制<code>Date</code>,<code>Array</code>,<code>Error</code>不被支持，但是<code>HTMLElement</code>是被支持的</p>
</blockquote>
<h3 id="Math-Number-String-Array-Object-APIs"><a href="#Math-Number-String-Array-Object-APIs" class="headerlink" title="Math + Number + String + Array + Object APIs"></a>Math + Number + String + Array + Object APIs</h3><p>ES6 为很多旧有对象添加了新的API，这些对象包括<code>Math</code>,<code>Array器</code>，<code>String</code>,<code>Object</code>，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.EPSILON</div><div class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">Infinity</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"NaN"</span>) <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">Math</span>.acosh(<span class="number">3</span>) <span class="comment">// 1.762747174039086</span></div><div class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 5</span></div><div class="line"><span class="built_in">Math</span>.imul(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">1</span>, <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>) - <span class="number">2</span>) <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="string">"abcde"</span>.includes(<span class="string">"cd"</span>) <span class="comment">// true</span></div><div class="line"><span class="string">"abc"</span>.repeat(<span class="number">3</span>) <span class="comment">// "abcabcabc"</span></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'*'</span>)) <span class="comment">// Returns a real Array</span></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// Similar to new Array(...), but without special one-arg behavior</span></div><div class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>].fill(<span class="number">7</span>, <span class="number">1</span>) <span class="comment">// [0,7,7]</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> x == <span class="number">3</span>) <span class="comment">// 3</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> x == <span class="number">2</span>) <span class="comment">// 1</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">3</span>, <span class="number">0</span>) <span class="comment">// [1, 2, 3, 1, 2]</span></div><div class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>].entries() <span class="comment">// iterator [0, "a"], [1,"b"], [2,"c"]</span></div><div class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>].keys() <span class="comment">// iterator 0, 1, 2</span></div><div class="line">[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>].values() <span class="comment">// iterator "a", "b", "c"</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(Point, &#123; <span class="attr">origin</span>: <span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>) &#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>babel 通过 polyfill 提供部分支持</p>
</blockquote>
<h3 id="二进制和八进制字面量"><a href="#二进制和八进制字面量" class="headerlink" title="二进制和八进制字面量"></a>二进制和八进制字面量</h3><p>ES6添加了二进制和八进制数值的字面量定义方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></div><div class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>babel 只支持字面量形式，不支持 Number(“0o767”)形式</p>
</blockquote>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise为异步编程提供了一种新的方式，Promise把未来将用到的值当做一等对象，Promise在很多前端库中已经有所支持了。这个平时用得最多了，还没使用的推荐试试。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">duration = <span class="number">0</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(resolve, duration);</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = timeout(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> timeout(<span class="number">2000</span>);</div><div class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"hmm"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([timeout(<span class="number">100</span>), timeout(<span class="number">200</span>)]);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>实际使用时需引入<a href="http://babeljs.io/docs/usage/polyfill/" target="_blank" rel="external">polyfill</a></p>
</blockquote>
<h3 id="Reflect-API"><a href="#Reflect-API" class="headerlink" title="Reflect API"></a>Reflect API</h3><p>Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API，作用如下：</p>
<ul>
<li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上；</li>
<li>修改某些Object方法的返回结果，让其变得更合理；</li>
<li>让Object操作都变成函数行为，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li>
<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> O = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(O, <span class="string">'b'</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;);</div><div class="line">O[<span class="built_in">Symbol</span>(<span class="string">'c'</span>)] = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="built_in">Reflect</span>.ownKeys(O); <span class="comment">// ['a', 'b', Symbol(c)]</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">a, b</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.c = a + b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance = <span class="built_in">Reflect</span>.construct(C, [<span class="number">20</span>, <span class="number">22</span>]);</div><div class="line">instance.c; <span class="comment">// 42</span></div></pre></td></tr></table></figure>
<blockquote>
<p>实际使用时需引入<a href="http://babeljs.io/docs/usage/polyfill/" target="_blank" rel="external">polyfill</a></p>
</blockquote>
<h3 id="Tail-Calls"><a href="#Tail-Calls" class="headerlink" title="Tail Calls"></a>Tail Calls</h3><p>尾部调用被保证不能无限拓展栈，这让有无限制输入时的递归算法更加安全。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, acc = <span class="number">1</span></span>) </span>&#123;</div><div class="line"><span class="meta">    'use strict'</span>;</div><div class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> acc;</div><div class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * acc);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 堆栈越来越常用，在ES6中其使用更加安全了</span></div><div class="line">factorial(<span class="number">100000</span>)</div></pre></td></tr></table></figure>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>上文对ES6的新特性都做了简单的描述，但是关于<code>Reflect API</code>和<code>Proxies</code>,由于本人对他们的理解还不够透彻，说得可能有些不清不楚。希望阅读本文让你有收获，有任何疑问，大家也可以一起讨论。</p>
<h3 id="有用的链接"><a href="#有用的链接" class="headerlink" title="有用的链接"></a>有用的链接</h3><ul>
<li><a href="https://github.com/lukehoban/es6features" target="_blank" rel="external">ECMAScript 6 Features</a></li>
<li><a href="https://babeljs.io/learn-es2015/" target="_blank" rel="external">Learn ES2015</a></li>
<li><a href="es6.ruanyifeng.com/#README">ECMAScript 6 入门</a></li>
<li><a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="external">You don’t know js</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/06/19/hello-world/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">zhang wang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>